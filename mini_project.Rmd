---
title: "Mini-Projet Etude et application de quelques schémas aux différences finies
  pour deux lois de conservation"
author: "AMECK GUY-MAX DESIRE DOSSEH & RIM ELMGHARI"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

On souhaite étudier, appliquer et voir le comportement de quelques schémas aux différences finies
pour deux équations relevant de lois de conservation 1D définies sur un domaine $\Omega = [0, L]$.

# 1. Equation de transport

On considère l'équation de transport soumise à des conditions aux limites périodiques:

$$
(E_{1})\left\{
\begin{array}{ll}
\frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, t=0) = u_0(x), & \forall x \in [0,L] \\
u(0, t) = u(L, t)\ ; \ \frac{\partial u}{\partial x}(L, t)=0 & \forall t > 0
\end{array}
\right.
$$
1) A l'aide de la méthode des caractéristiques, déterminer la solution exacte $u(x, t)$ du problème $(E_{1})$.

Nous allons chercher une courbe caractéristique $\Gamma ((t(s), x(s))$, s étant le paramètre qui décrit la courbe, le long de laquelle l'EDP devient un système d'EDO.

$$
\begin{aligned}
du &= \frac{\partial u}{\partial t}dt + \frac{\partial u}{\partial x}dx\\
\frac{du}{ds} &= \frac{\partial u}{\partial t}\frac{dt}{ds} + \frac{\partial u}{\partial x}\frac{dx}{ds}\\
\frac{du}{ds} &= -a\frac{\partial u}{\partial x}\frac{dt}{ds} + \frac{\partial u}{\partial x}\frac{dx}{ds}\\
\frac{du}{ds} &= \frac{\partial u}{\partial x}(\frac{dx}{ds}-a\frac{dt}{ds})
\end{aligned}
$$

On voit que si on impose $\frac{dx}{ds}-a\frac{dt}{ds} = 0$, on a $\frac{du}{ds} = 0$, c'est à dire que u est constant le long de la courbe caractéristique. 

On a donc le système d'EDO suivant a résoudre:

$$
\left\{
\begin{array}{ll}
\frac{dx}{dt} = a \ \text{qui donne la courbe caractéristique }\Gamma\\
du = 0 \ \text{qui donne la solution u(x, t) sur cette courbe caractéristique} 
\end{array}
\right.
$$
\newpage

**Courbes caractéristiques:**

$$
\frac{dx}{dt} = a \ \text{donne} \ x(t) = at + \xi (avec \ \xi \ \text{une constante reelle d'integration})
$$

```{python, warning=FALSE, message=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

# Define the values of a and xi
a = 2
xi_values = [-4, -3, -2, -1, 0, 1, 2, 3, 4]

# Define the time range
t = np.linspace(-10, 10, 100)

plt.figure(figsize=(12, 8))
# Plot the characteristic curves for each xi value
for xi in xi_values:
    x = a * t + xi
    plt.plot(t, x, label=f"xi = {xi}")

# Plot the x and y axes
plt.axhline(0, color='black')
plt.axvline(0, color='black')

plt.xlabel('Time')
plt.ylabel('x(t)')
plt.title('Courbes Caracteristiques')
plt.grid(True)
plt.legend()

# Set the x and y axes limits to center at 0
_ = plt.xlim(-10, 10)
_ = plt.ylim(-10, 10)

# Set the x and y axis ticks
_ = plt.xticks(np.arange(-10, 11, 2))
_ = plt.yticks(np.arange(-10, 11, 2))

# Hide the legend
plt.legend().set_visible(False)
plt.show()
```

**Solution**

Sur chaque courbe caractéristique $(\Gamma): x-at = \xi$, on a:

$$
du = 0 \Rightarrow u(x, t) =  cte = f(\xi) \leftarrow i.e. \text{ u ne depend que de } \xi 
$$
Soit alors 

$$
u(x, t) = f(x-at)
$$
Cette solution doit être retrouvée aussi pour $t=0$.

Or a $t=0$, on a:

$$
u(x, 0) = u_0(x) = f(x) \Rightarrow f(x) = u_0(x)
$$

c'est a dire $$f\equiv u_0$$

On obtient finalement la solution exacte du problème $(E_{1})$:

$$
u(x, t) = u_0(x-at), \ \forall x \in [0, L], \ \forall t > 0
$$
Elle est périodique en x, de période L.


On discrétoire l'intervalle $[0, L]$ en $(N-1)$ sous-intervalles $[x_{i}, x_{i+1}](i=1, ..., N-1)$ de tailles égales $\Delta x(\Delta x=\frac{L}{N-1}, x_{i+1}=x_{i}+\Delta x)$, et on note par $u_{i}^{n}$ la solution approchée au nœud $x_{i}$ a l'instant $t^{n}=n\Delta t$($\Delta t$ étant le pas de change).


2) Etudier la consistance, la stabilité et la convergence de chacun des schémas numériques suivants:


**Schéma 1 (centre):**

$$
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0
$$


- **Consistance**

Utilisons le développement de Taylor pour évaluer la consistance du schéma. On a:

+ D'une part le développement de Taylor de $u_{j}^{n+1}$ à l'ordre 1 :

$$
\begin{aligned}
u_{j}^{n+1} &= u_{j}^{n} + \Delta t\frac{\partial u}{\partial t}|_{j}^{n} + O(\Delta t^2)\\ 
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + O(\Delta t)
\end{aligned}  
$$



+ Et d’autre part le développement de Taylor de $u_{j+1}^{n}$ et $u_{j-1}^{n}$ à schéma 2 :

$$
\begin{aligned}
u_{j+1}^{n} &= u_{j}^{n} + \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} + O((\Delta x)^3)\\
u_{j-1}^{n} &= u_{j}^{n} - \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} + O((\Delta x)^3)\\
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} + O((\Delta x)^2)\\
\end{aligned} 
$$

On obtient alors le schéma numérique:

$$
\begin{cases}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0 &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$

dont l'erreur de troncature est:

$$
\begin{aligned}
\text{ET} &= ( \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}) -(\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x})\\
&= \mathcal{O}(\Delta t) + \mathcal{O}((\Delta x)^2)\\
\end{aligned}
$$

Nous avons donc un schéma d'ordre 1 en temps et d'ordre 2 en espace. 
Par définition de la consistance, Un schéma est dit consistant si l'erreur de troncature tend vers 0 lorsque $\Delta t$ et $\Delta x$ tendent vers 0. Soit:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Dans notre cas, on a:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = \mathcal{O}(\Delta t) + \mathcal{O}((\Delta x)^2)
$$

Or 

$$
|\mathcal{O}(\Delta t)| \leq C|\Delta t|  \implies \lim_{\Delta t \to 0} \mathcal{O}(\Delta t) = 0
$$
et

$$
|\mathcal{O}((\Delta x)^2)| \leq C|\Delta x|^2  \implies \lim_{\Delta x \to 0} \mathcal{O}((\Delta x)^2) = 0
$$

D'où:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Par suite, le schéma 1 centre est consistant.


- **Stabilité**

Pour étudier la stabilité du schéma, on utilise la méthode de Von Neumann. On pose:

$$
u_{j}^{n} = C^{n}e^{i\xi x_{j}}, \text{ avec } x_j = j\Delta x \text{ et } \xi \text{ est le nombre d'onde}
$$
et on injecte cette solution dans le schéma numérique:

$$
\begin{aligned}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0 & \implies \frac{C^{n+1}e^{i\xi x_{j}}-C^{n}e^{i\xi x_{j}}}{\Delta t} + a\frac{C^{n}e^{i\xi x_{j+1}}-C^{n}e^{i\xi x_{j-1}}}{2\Delta x} = 0\\
       & \implies \frac{C^{n+1}e^{i\xi j\Delta x}-C^{n}e^{i\xi j\Delta x}}{\Delta t} + a\frac{C^{n}e^{i\xi (j+1)\Delta x}-C^{n}e^{i\xi (j-1)\Delta x}}{2\Delta x} = 0\\
       & \implies \frac{C^{n+1}-C^{n}}{\Delta t}e^{i\xi j\Delta x} + a\frac{e^{i\xi \Delta x}-e^{-i\xi \Delta x}}{2\Delta x}C^{n}e^{i\xi j\Delta x} = 0\\
       & \implies C^{n+1} = C^{n} - \frac{a\Delta t}{\Delta x}sin(\xi \Delta x)C^{n}\\
       & \implies C^{n+1} = (1 - \frac{a\Delta t}{\Delta x}isin(\xi \Delta x))C^{n}\\
       & \implies C^{n+1} = (1 - i\lambda sin(\xi \Delta x))C^{n}, \text{ avec } \lambda = \frac{a\Delta t}{\Delta x}\\
       & \implies C^{n+1} = (1 - i\lambda sin(\xi \Delta x))^{n}C^{0}
\end{aligned}
$$



On doit avoir $|1 - i\lambda sin(\xi \Delta x)|\leq 1\  \forall \xi \in \mathbb{R}$


On a:

$$
\begin{aligned}
|1 - i\lambda sin(\xi \Delta x)|^2 &\leq 1\\
1+\lambda^2sin^{2}(\xi \Delta x) &\leq 1\\
\lambda^2sin^{2}(\xi \Delta x) &\leq 0 \ (\text{  ce qui est absurde})\\
\end{aligned}
$$

Ainsi, le schéma 1 centre est instable.

- **Convergence**

En utilisant la contraposée du théorème de Lax, on a:

Le schéma 1 centre n'est pas stable, donc il n'est pas convergent.


**Schéma 2 (décentré):**

$$
\begin{aligned}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j}^{n}-u_{j-1}^{n}}{\Delta x} = 0 & \text{ si } a > 0\\
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x} = 0 & \text{ si } a < 0
\end{aligned}
$$

- **Cas a > 0**

    - **Consistance**

Utilisons le développement de Taylor pour évaluer la consistance du schéma. On a:

+ D'une part le développement de Taylor de $u_{j}^{n+1}$ à l'ordre 1 :

$$
\begin{aligned}
u_{j}^{n+1} &= u_{j}^{n} + \Delta t\frac{\partial u}{\partial t}|_{j}^{n} + O(\Delta t^2)\\
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + O(\Delta t)
\end{aligned}
$$
+ Et d’autre part le développement de Taylor de $u_{j}^{n}$ et $u_{j-1}^{n}$ à ordre 1 :

$$
\begin{aligned}
u_{j}^{n} &= u_{j}^{n} + \Delta x\frac{\partial u}{\partial x} + O(\Delta x^2)\\
u_{j-1}^{n} &= u_{j}^{n} - \Delta x\frac{\partial u}{\partial x} + O(\Delta x^2)\\
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j}^{n}-u_{j-1}^{n}}{\Delta x} + O(\Delta x)
\end{aligned} 
$$


On obtient alors le schéma numérique:

$$
\begin{cases}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j}^{n}-u_{j-1}^{n}}{\Delta x} = 0 &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$

dont l'erreur de troncature est:

$$
\begin{aligned}
\text{ET} &= ( \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}) -(\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j}^{n}-u_{j-1}^{n}}{\Delta x})\\
&= \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)\\
\end{aligned}
$$

Nous avons donc un schéma d'ordre 1 en temps et d'ordre 1 en espace.

Par définition de la consistance, Un schéma est dit consistant si l'erreur de troncature tend vers 0 lorsque $\Delta t$ et $\Delta x$ tendent vers 0. Soit:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0 
$$

Dans notre cas, on a:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)
$$

Or

$$
|\mathcal{O}(\Delta t)| \leq C|\Delta t|  \implies \lim_{\Delta t \to 0} \mathcal{O}(\Delta t) = 0 
$$

et

$$
|\mathcal{O}(\Delta x)| \leq C|\Delta x|  \implies \lim_{\Delta x \to 0} \mathcal{O}(\Delta x) = 0 
$$

D'où:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Par suite, le schéma 2 décentré en amont est consistant.


- **Stabilité**

Pour étudier la stabilité du schéma, on utilise la méthode de Von Neumann. On pose:

$$
u_{j}^{n} = C^{n}e^{i\xi x_{j}}, \text{ avec } x_j = j\Delta x \text{ et } \xi \text{ est le nombre d'onde} 
$$

et on injecte cette solution dans le schéma numérique:

$$
\begin{aligned}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j}^{n}-u_{j-1}^{n}}{\Delta x} = 0 & \implies \frac{C^{n+1}e^{i\xi x_{j}}-C^{n}e^{i\xi x_{j}}}{\Delta t} + a\frac{C^{n}e^{i\xi x_{j}}-C^{n}e^{i\xi x_{j-1}}}{\Delta x} = 0\\
       & \implies \frac{C^{n+1}e^{i\xi j\Delta x}-C^{n}e^{i\xi j\Delta x}}{\Delta t} + a\frac{C^{n}e^{i\xi j\Delta x}-C^{n}e^{i\xi (j-1)\Delta x}}{\Delta x} = 0\\
       & \implies \frac{C^{n+1}-C^{n}}{\Delta t}e^{i\xi j\Delta x} + a\frac{1-e^{-i\xi \Delta x}}{\Delta x}C^{n}e^{i\xi j\Delta x} = 0\\
       & \implies C^{n+1} = C^{n} - \frac{a\Delta t}{\Delta x}(1-e^{-i\xi \Delta x})C^{n}\\
       & \implies C^{n+1} = (1 - \frac{a\Delta t}{\Delta x}(1-e^{-i\xi \Delta x}))C^{n}\\
       & \implies C^{n+1} = (1 - \lambda (1-e^{-i\xi \Delta x}))C^{n}, \text{ avec } \lambda = \frac{a\Delta t}{\Delta x}\\
\end{aligned}
$$

On doit avoir $|1 - \lambda (1-e^{-i\xi \Delta x})|\leq 1\  \forall \xi \in \mathbb{R}$

\newpage

On a:

$$
\begin{aligned}
|1 - \lambda (1-e^{-i\xi \Delta x})|^2 &\leq 1\\
|1 - \lambda(1-(cos(-\xi\Delta x)+isin(-\xi\Delta x)))|^2 &\leq 1\\
|1 - \lambda(1-cos(\xi\Delta x)+isin(\xi\Delta x))|^2 &\leq 1\\
|1 - \lambda+\lambda cos(\xi\Delta x)-i\lambda sin(\xi\Delta x))|^2 &\leq 1\\
(1 - \lambda+\lambda cos(\xi\Delta x))^2+(\lambda sin(\xi\Delta x))^2 &\leq 1\\
1 - 2\lambda+\lambda^2 +\lambda^2cos^2(\xi\Delta x)+2(1-\lambda)\lambda cos(\xi\Delta x)+\lambda^2sin^2(\xi\Delta x) &\leq 1\\
1 - 2\lambda+2\lambda^2 +2(1-\lambda)\lambda cos(\xi\Delta x) &\leq 1\\
2\lambda^2 - 2\lambda+2(1-\lambda)\lambda cos(\xi\Delta x) &\leq 0\\
\lambda^2 - \lambda+(1-\lambda)\lambda cos(\xi\Delta x) &\leq 0\\
\lambda(\lambda-1)-(\lambda-1)\lambda cos(\xi\Delta x) &\leq 0\\
\lambda(\lambda-1)(1- cos(\xi\Delta x)) &\leq 0\\
\end{aligned}
$$

Or $\lambda > 0$ et $1-cos(\xi\Delta x) \geq 0$, on doit donc avoir:

$$
\begin{aligned}
\lambda - 1 &\leq 0\\
\lambda &\leq 1\\
\lambda=\frac{a\Delta t}{\Delta x} &\leq 1
\end{aligned}
$$

Ainsi, le schéma 2 décentré en amont est stable si $\frac{a\Delta t}{\Delta x} \leq 1$.

- **Convergence**

Le schéma 2 décentré étant consistant et conditionnellement stable; en utilisant le théorème de Lax sous les mêmes conditions de stabilité, on déduit que le schéma 2 décentré en amont($a>0$) est convergent.

- **Cas a < 0**

    - **Consistance**
    
Utilisons le développement de Taylor pour évaluer la consistance du schéma. On a:

+ D'une part le développement de Taylor de $u_{j}^{n+1}$ à l'ordre 1 :

$$
\begin{aligned}
u_{j}^{n+1} &= u_{j}^{n} + \Delta t\frac{\partial u}{\partial t}|_{j}^{n} + O(\Delta t^2)\\
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + O(\Delta t)
\end{aligned}
$$

+ Et d’autre part le développement de Taylor de $u_{j+1}^{n}$ et $u_{j}^{n}$ à ordre 1 :

$$
\begin{aligned}
u_{j+1}^{n} &= u_{j}^{n} + \Delta x\frac{\partial u}{\partial x} + O(\Delta x^2)\\
u_{j}^{n} &= u_{j}^{n} - \Delta x\frac{\partial u}{\partial x} + O(\Delta x^2)\\
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x} + O(\Delta x)
\end{aligned}
$$

On obtient alors le schéma numérique:

$$
\begin{cases}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x} = 0 &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$

dont l'erreur de troncature est:

$$
\begin{aligned}
\text{ET} &= ( \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}) -(\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x})\\
&= \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)\\
\end{aligned}
$$

Nous avons donc un schéma d'ordre 1 en temps et d'ordre 1 en espace.

Par définition de la consistance, un schéma est dit consistant si l'erreur de troncature tend vers 0 lorsque $\Delta t$ et $\Delta x$ tendent vers 0. Soit:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$


Dans notre cas, on a:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)
$$

Or

$$
|\mathcal{O}(\Delta t)| \leq C|\Delta t|  \implies \lim_{\Delta t \to 0} \mathcal{O}(\Delta t) = 0
$$

et

$$
|\mathcal{O}(\Delta x)| \leq C|\Delta x|  \implies \lim_{\Delta x \to 0} \mathcal{O}(\Delta x) = 0
$$

D'où:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Par suite, le schéma 2 décentré en aval est consistant.


- **Stabilité**

    
Pour étudier la stabilité du schéma, on utilise la méthode de Von Neumann. On pose:

$$
u_{j}^{n} = C^{n}e^{i\xi x_{j}}, \text{ avec } x_j = j\Delta x \text{ et } \xi \text{ est le nombre d'onde}
$$

\newpage

et on injecte cette solution dans le schéma numérique:

$$
\begin{aligned}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x} = 0 & \implies \frac{C^{n+1}e^{i\xi x_{j}}-C^{n}e^{i\xi x_{j}}}{\Delta t} + a\frac{C^{n}e^{i\xi x_{j+1}}-C^{n}e^{i\xi x_{j}}}{\Delta x} = 0\\
       & \implies \frac{C^{n+1}e^{i\xi j\Delta x}-C^{n}e^{i\xi j\Delta x}}{\Delta t} + a\frac{C^{n}e^{i\xi (j+1)\Delta x}-C^{n}e^{i\xi j\Delta x}}{\Delta x} = 0\\
       & \implies \frac{C^{n+1}-C^{n}}{\Delta t}e^{i\xi j\Delta x} + a\frac{e^{i\xi \Delta x}-1}{\Delta x}C^{n}e^{i\xi j\Delta x} = 0\\
       & \implies C^{n+1} = C^{n} - \frac{a\Delta t}{\Delta x}(e^{i\xi \Delta x}-1)C^{n}\\
       & \implies C^{n+1} = (1 - \lambda(e^{i\xi \Delta x}-1))C^{n}, \text{ avec } \lambda = \frac{a\Delta t}{\Delta x}\\
\end{aligned}
$$

On doit avoir $|1 - \lambda(e^{i\xi \Delta x}-1)|\leq 1\  \forall \xi \in \mathbb{R}$


On a:

$$
\begin{aligned}
|1 - \lambda(e^{i\xi \Delta x}-1)|^2 &\leq 1\\
|1 - \lambda(cos(\xi\Delta x)+isin(\xi\Delta x)-1)|^2 &\leq 1\\
|1 - \lambda - \lambda cos(\xi\Delta x)-i\lambda sin(\xi\Delta x)|^2 &\leq 1\\
(1 - \lambda)^2 + \lambda^2cos^2(\xi\Delta x)-2(1 - \lambda)\lambda cos(\xi\Delta x)+\lambda^2sin^2(\xi\Delta x) &\leq 1\\
1 - 2\lambda+\lambda^2 +\lambda^2cos^2(\xi\Delta x)-2(1 - \lambda)\lambda cos(\xi\Delta x)+\lambda^2sin^2(\xi\Delta x) &\leq 1\\
1 - 2\lambda+2\lambda^2 +2\lambda (\lambda-1)cos(\xi\Delta x) &\leq 1\\
2\lambda^2 - 2\lambda+2\lambda (\lambda-1)cos(\xi\Delta x) &\leq 0\\
2\lambda(\lambda-1) +2\lambda (\lambda-1)cos(\xi\Delta x) &\leq 0\\
2\lambda(\lambda-1)(1 + cos(\xi\Delta x)) &\leq 0\\
4\lambda(\lambda -1)cos^2\frac{\xi\Delta x}{2} &\leq 0\\
\end{aligned}
$$


Le schéma 2 décentré en aval est stable si $\lambda < 0\implies a<0$.


- **Convergence**
    
Le schéma 2 décentré étant consistant et stable; en utilisant le théorème de Lax, on déduit que le schéma 2 décentré en aval ($a<0$) est convergent.

\newpage

**Schéma 3 (Lax-Friedrichs):**

$$
\frac{u_{j}^{n+1}-\frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n})}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0
$$

- **Consistance**

Utilisons le développement de Taylor pour évaluer la consistance du schéma. On a:

+ D'une part le développement de Taylor de $u_{j+1}^{n}$ et $u_{j-1}^{n}$ à ordre 2 :

$$
\begin{aligned}
u_{j+1}^{n} &= u_{j}^{n} + \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} + O((\Delta x)^3)\\
u_{j-1}^{n} &= u_{j}^{n} - \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} + O((\Delta x)^3)\\
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} + O((\Delta x)^2)\\
\end{aligned}
$$



+ D'une part le développement de Taylor de $u_{j}^{n+1}$ à l'ordre 1:

$$
\begin{aligned}
u_{j}^{n+1} &= u_{j}^{n} + \Delta t\frac{\partial u}{\partial t}|_{j}^{n} + O(\Delta t^2)\\
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + O(\Delta t)
\end{aligned}
$$

En utilisant les deux premiers développement de Taylor tronques a l'ordre 1, on obtient $u_j^n$ comme somme de $u_{j+1}^{n}$ et $u_{j-1}^{n}$:


$$
\begin{aligned}
u_{j}^{n} &= \frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n}) + O((\Delta x)^2)
\end{aligned}
$$

En remplaçant dans le troisième développement de Taylor, on obtient:

$$
\begin{aligned}
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-\frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n})}{\Delta t} + O(\Delta t)\\
\end{aligned}
$$


On obtient alors le schéma numérique:

$$
\begin{cases}
\frac{u_{j}^{n+1}-\frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n})}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0 &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$

dont l'erreur de troncature est:

$$
\begin{aligned}
\text{ET} &= ( \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}) -(\frac{u_{j}^{n+1}-\frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n})}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x})\\
&= \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)^2\\
\end{aligned}
$$

Nous avons donc un schéma d'ordre 1 en temps et d'ordre 2 en espace.

Par définition de la consistance, Un schéma est dit consistant si l'erreur de troncature tend vers 0 lorsque $\Delta t$ et $\Delta x$ tendent vers 0. Soit:


$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$


Dans notre cas, on a:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = \mathcal{O}(\Delta t) + \mathcal{O}(\Delta x)^2
$$

Or

$$
|\mathcal{O}(\Delta t)| \leq C|\Delta t|  \implies \lim_{\Delta t \to 0} \mathcal{O}(\Delta t) = 0
$$

et

$$
|\mathcal{O}(\Delta x)^2| \leq C|\Delta x|^2  \implies \lim_{\Delta x \to 0} \mathcal{O}(\Delta x)^2 = 0
$$


D'où:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Par suite, le schéma 3 Lax-Friedrichs est consistant.


- **Stabilité**

Pour étudier la stabilité du schéma, on utilise la méthode de Von Neumann. On pose:

$$
u_{j}^{n} = C^{n}e^{i\xi x_{j}}, \text{ avec } x_j = j\Delta x \text{ et } \xi \text{ est le nombre d'onde}
$$

et on injecte cette solution dans le schéma numérique:

$$
\begin{aligned}
&  \frac{u_{j}^{n+1}-\frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n})}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0\\
&  \frac{C^{n+1}e^{i\xi x_{j}}-\frac{1}{2}(C^{n}e^{i\xi x_{j-1}}+C^{n}e^{i\xi x_{j+1}})}{\Delta t} + a\frac{C^{n}e^{i\xi x_{j+1}}-C^{n}e^{i\xi x_{j-1}}}{2\Delta x} = 0\\
       &  \frac{C^{n+1}e^{i\xi j\Delta x}-\frac{1}{2}(C^{n}e^{i\xi (j-1)\Delta x}+C^{n}e^{i\xi (j+1)\Delta x})}{\Delta t} + a\frac{C^{n}e^{i\xi (j+1)\Delta x}-C^{n}e^{i\xi (j-1)\Delta x}}{2\Delta x} = 0\\
       &  \frac{C^{n+1}-\frac{1}{2}(C^{n}e^{-i\xi \Delta x}+C^{n}e^{i\xi \Delta x})}{\Delta t} + a\frac{e^{i\xi \Delta x}-e^{-i\xi \Delta x}}{2\Delta x}C^{n} = 0\\
       &  C^{n+1} = \frac{1}{2}(C^{n}e^{-i\xi \Delta x}+C^{n}e^{i\xi \Delta x}) - \frac{a\Delta t}{2\Delta x}(e^{i\xi \Delta x}-e^{-i\xi \Delta x})C^{n}\\
       &  C^{n+1} = \frac{1}{2}(C^{n}(cos(\xi \Delta x)-isin(\xi \Delta x)+cos(\xi \Delta x)+isin(\xi \Delta x)) - \frac{a\Delta t}{2\Delta x}(cos(\xi \Delta x)+isin(\xi \Delta x)-cos(\xi \Delta x)+isin(\xi \Delta x))C^{n}\\
       &  C^{n+1} = \frac{1}{2}(2cos(\xi\Delta x)-\frac{a\Delta t}{2\Delta x}2isin(\xi\Delta x))C^{n}\\
       &  C^{n+1} = (cos(\xi\Delta x)-i\lambda sin(\xi\Delta x))C^{n}, \text{ avec } \lambda = \frac{a\Delta t}{\Delta x}\\
\end{aligned}
$$

On doit avoir $|cos(\xi\Delta x)-i\lambda sin(\xi\Delta x)|\leq 1\  \forall \xi \in \mathbb{R}$

\newpage

On a:

$$
\begin{aligned}
|cos(\xi\Delta x)-i\lambda sin(\xi\Delta x)|^2 &\leq 1\\
(cos(\xi\Delta x))^2+(\lambda sin(\xi\Delta x))^2 &\leq 1\\
cos^2(\xi\Delta x)+\lambda^2sin^2(\xi\Delta x) &\leq 1\\
1- sin^2(\xi\Delta x)+\lambda^2sin^2(\xi\Delta x) &\leq 1\\
1-(1-\lambda^2)sin^2(\xi\Delta x) &\leq 1\\
-(1-\lambda^2)sin^2(\xi\Delta x) &\leq 0\\
1-\lambda^2 &\geq 0\\
\lambda^2 &\leq 1\\
\lambda=\frac{a\Delta t}{\Delta x} &\leq 1
\end{aligned}
$$

Ainsi, le schéma 3 Lax-Friedrichs est stable si $\frac{a\Delta t}{\Delta x} \leq 1$(**condition de  Courant-Friedrichs-Lewy**).

- **Convergence**

Le schéma 3 Lax-Friedrichs étant consistant et conditionnellement stable; en utilisant le théorème de Lax, on déduit que le schéma 3 Lax-Friedrichs est convergent.


**Schéma 4 (Lax-Wendroff):**

$$
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}) = 0
$$


- **Consistance**

Utilisons le développement de Taylor pour évaluer la consistance du schéma. On a:

Le développement de Taylor de $u$ en $(x_j, t^n+\Delta t)$ a l'ordre 2 est:

$$
\begin{aligned}
u(x_j, t^n+\Delta t) &= u(x_j, t^n) + \Delta t\frac{\partial u}{\partial t}(x_j, t^n) + \frac{1}{2}(\Delta t)^2 \frac{\partial^2 u}{\partial t^2}(x_j, t^n) + \mathcal{O}((\Delta t)^3)\\
\end{aligned}
$$

Or $\frac{\partial u}{\partial t}+a\frac{\partial u}{\partial x}=0$, donc:

$\frac{\partial u}{\partial t} = -a \frac{\partial u}{\partial x}$ et $\frac{\partial^2 u}{\partial t^2} = -a \frac{\partial^2 u}{\partial x \partial t}=a^{2}\frac{\partial^2 u}{\partial x^2}$

D'où:

$$
\begin{aligned}
u(x_j, t^n+\Delta t) &= u(x_j, t^n) - a\Delta t\frac{\partial u}{\partial x}(x_j, t^n) + \frac{1}{2}a^{2}(\Delta t)^2 \frac{\partial^2 u}{\partial x^2}(x_j, t^n) + \mathcal{O}((\Delta t)^3)\\
u_j^{n+1} &= u_j^{n} - a\Delta t\frac{\partial u}{\partial x}|_{j}^{n} + \frac{1}{2}a^{2}(\Delta t)^2 \frac{\partial^2 u}{\partial x^2}|_{j}^{n} + \mathcal{O}((\Delta t)^3)\\
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta t} -\frac{a^2}{2}\Delta t\frac{\partial^2 u}{\partial x^2}|_{j}^{n} + \mathcal{O}((\Delta t)^2)\\
\end{aligned}
$$

\newpage

Utilisons les développements de Taylor de $u_{j+1}^{n}$ et $u_{j-1}^{n}$ a l'ordre 3 pour approximer la dérivée seconde de $u$ par rapport a $x$:

$$
\begin{aligned}
u_{j+1}^{n} &= u_{j}^{n} + \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} + \frac{(\Delta x)^3}{6}\frac{\partial^3 u}{\partial x^3} + \mathcal{O}((\Delta x)^4)\\
u_{j-1}^{n} &= u_{j}^{n} - \Delta x\frac{\partial u}{\partial x} + \frac{(\Delta x)^2}{2}\frac{\partial^2 u}{\partial x^2} - \frac{(\Delta x)^3}{6}\frac{\partial^3 u}{\partial x^3} + \mathcal{O}((\Delta x)^4)\\
\frac{\partial^2 u}{\partial x^2}|_{j}^{n} &=\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{(\Delta x)^2} + \mathcal{O}((\Delta x))\\
\end{aligned}
$$

On a finalement comme approximation pour la dérivée temporelle de $u$:

$$
\begin{aligned}
\frac{\partial u}{\partial t}|_{j}^{n} &=\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t}  - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}) + \mathcal{O}((\Delta t)^2)\\
\end{aligned}
$$

En utilisant les développements de Taylor de $u_{j+1}^{n}$ et $u_{j-1}^{n}$ a l'ordre 2 précédents, on obtient comme pour approximation pour la dérivée spatiale:

$$
\begin{aligned}
\frac{\partial u}{\partial x}|_{j}^{n} &=\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} + \mathcal{O}((\Delta x)^2)\\
\end{aligned}
$$

On obtient alors le schéma numérique:

$$
\begin{cases}
\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}) = 0 &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$

dont l'erreur de troncature est:

$$
\begin{aligned}
\text{ET} &= ( \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}) -(\frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}))\\
&= \mathcal{O}(\Delta t)^2 + \mathcal{O}(\Delta x)^2\\
\end{aligned}
$$

Nous avons donc un schéma d'ordre 2 en temps et d'ordre 2 en espace.

Par définition de la consistance, Un schéma est dit consistant si l'erreur de troncature tend vers 0 lorsque $\Delta t$ et $\Delta x$ tendent vers 0. Soit:


$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$



Dans notre cas, on a:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = \mathcal{O}(\Delta t)^2 + \mathcal{O}(\Delta x)^2
$$

Or

$$
|\mathcal{O}(\Delta t)^2| \leq C|\Delta t|^2  \implies \lim_{\Delta t \to 0} \mathcal{O}(\Delta t)^2 = 0
$$

\newpage

et

$$
|\mathcal{O}(\Delta x)^2| \leq C|\Delta x|^2  \implies \lim_{\Delta x \to 0} \mathcal{O}(\Delta x)^2 = 0
$$


D'où:

$$
\lim_{\Delta t, \Delta x \to 0} \text{ET} = 0
$$

Par suite, le schéma 4 Lax-Wendroff est consistant.


- **Stabilité**

Pour étudier la stabilité du schéma, on utilise la méthode de Von Neumann. On pose:

$$
u_{j}^{n} = C^{n}e^{i\xi x_{j}}, \text{ avec } x_j = j\Delta x \text{ et } \xi \text{ est le nombre d'onde}
$$

et on injecte cette solution dans le schéma numérique:

$$
\begin{aligned}
&  \frac{u_{j}^{n+1}-u_{j}^{n}}{\Delta t} + a\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}) = 0\\
&  \frac{C^{n+1}e^{i\xi x_{j}}-C^{n}e^{i\xi x_{j}}}{\Delta t} + a\frac{C^{n}e^{i\xi x_{j+1}}-C^{n}e^{i\xi x_{j-1}}}{2\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(C^{n}e^{i\xi x_{j-1}}-2C^{n}e^{i\xi x_{j}}+C^{n}e^{i\xi x_{j+1}}) = 0\\
       &  \frac{C^{n+1}e^{i\xi j\Delta x}-C^{n}e^{i\xi j\Delta x}}{\Delta t} + a\frac{e^{i\xi \Delta x}-e^{-i\xi \Delta x}}{2\Delta x}e^{i\xi j\Delta x}C^{n} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(e^{-i\xi \Delta x}-2+e^{i\xi \Delta x})e^{i\xi j\Delta x}C^{n} = 0\\
       &  \frac{C^{n+1}-C^{n}}{\Delta t}e^{i\xi j\Delta x} + a\frac{e^{i\xi \Delta x}-e^{-i\xi \Delta x}}{2\Delta x}C^{n}e^{i\xi j\Delta x} - \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(e^{-i\xi \Delta x}-2+e^{i\xi \Delta x})C^{n}e^{i\xi j\Delta x} = 0\\
       &  C^{n+1} = C^{n} - \frac{a\Delta t}{\Delta x}(isin(\xi \Delta x))C^{n} + \frac{a^{2}(\Delta t)^2}{(\Delta x)^{2}}(cos(\xi \Delta x)-1)C^{n}\\
       &  C^{n+1} = (1 - i\lambda sin(\xi \Delta x) + \lambda^2(cos(\xi \Delta x)-1))C^{n}, \text{ avec } \lambda = \frac{a\Delta t}{\Delta x}\\
\end{aligned}
$$



On doit avoir $|1 - i\lambda sin(\xi \Delta x) + \lambda^2(cos(\xi \Delta x)-1)|\leq 1\  \forall \xi \in \mathbb{R}$

\newpage

On a:

$$
\begin{aligned}
|1 - i\lambda sin(\xi \Delta x) + \lambda^2(cos(\xi \Delta x)-1)|^2 &\leq 1\\
|1 - i\lambda sin(\xi \Delta x) - 2\lambda^2sin^2(\frac{\xi \Delta x}{2})|^2 &\leq 1\\
|1 - 2\lambda^2sin^2(\frac{\xi \Delta x}{2}) - i\lambda sin(\xi \Delta x)|^2 &\leq 1\\
(1 - 2\lambda^2sin^2(\frac{\xi \Delta x}{2}))^2 + (\lambda sin(\xi \Delta x))^2 &\leq 1\\
1 - 4\lambda^2sin^2(\frac{\xi \Delta x}{2}) + 4\lambda^4sin^4(\frac{\xi \Delta x}{2}) + \lambda^2 sin^2(\xi \Delta x) &\leq 1\\
- 4\lambda^2sin^2(\frac{\xi \Delta x}{2}) + 4\lambda^4sin^4(\frac{\xi \Delta x}{2}) + \lambda^2 [4sin^{2}(\frac{\xi \Delta x}{2})-4sin^{4}(\frac{\xi \Delta x}{2})]&\leq 0\\
- 4\lambda^2sin^2(\frac{\xi \Delta x}{2}) + 4\lambda^4sin^4(\frac{\xi \Delta x}{2}) + 4\lambda^2sin^{2}(\frac{\xi \Delta x}{2})-4\lambda^2sin^{4}(\frac{\xi \Delta x}{2})&\leq 0\\
 4\lambda^4sin^4(\frac{\xi \Delta x}{2}) -4\lambda^2sin^{4}(\frac{\xi \Delta x}{2})&\leq 0\\
 4\lambda^2(\lambda^2-1)sin^4(\frac{\xi\Delta x}{2})\leq 0\\
 sup_{\xi\in \mathbb{R}}[ 4\lambda^2(\lambda^2-1)sin^4(\frac{\xi\Delta x}{2})] \leq 0\\
 4\lambda^2(\lambda^2-1) \leq 0\\
 \lambda^2(\lambda^2-1) \leq 0\\
 \lambda^2 -1 \leq 0\\
 \lambda^2 \leq 1\\
 \lambda \leq 1\\
 \frac{a\Delta t}{\Delta x} \leq 1
\end{aligned}
$$

Ainsi, le schéma 4 Lax-Wendroff est  stable si $\lambda=\frac{a\Delta t}{\Delta x}\leq 1$.


- **Convergence**

Le schéma 4 Lax-Wendroff étant consistant et stable; en utilisant le théorème de Lax, on déduit que le schéma 4 Lax-Wendroff est convergent.


\newpage


3) Implémenter chacun des schémas numériques pour évaluer la solution approchée, puis comparer cette solution avec la solution exacte. (Tracer les solutions aux temps physiques t1 = 2.5 s et t2 = 4.5 s en testant sur deux maillages différents formés de N = 100 et N = 200 points. Interpréter les résultats.

- **Schéma 1 (centré):**

Schéma numérique:

$$
\begin{cases}
u_{j}^{n+1} = u_{j}^{n} - \frac{a\Delta t}{2\Delta x}(u_{j+1}^{n}-u_{j-1}^{n}) &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$




```{python, message=FALSE, warning=FALSE, echo=FALSE, out.width="100%"}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0

L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]
    
    t += dt

u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[0, 0].plot(x, u_exact, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-1.5, 1.5)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]
    
    t += dt

u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[0, 1].plot(x, u_exact, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-1.5, 1.5)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=100
N = 200
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
u = u0.copy()

while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]
    
    t += dt

u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[1, 0].plot(x, u_exact, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-1.5, 1.5)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt

u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[1, 1].plot(x, u_exact, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-1.5, 1.5)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema Centre", y=1.12)
plt.show()
```



- On remarque que pour le schéma centre, la solution numérique est instable pour $N=100$ et $N=200$.

- La solution exacte quant a elle, a $t=2.5s$ a subi un transport vers la droite de 5m.

- A $t=4.5s$, la solution exacte a subi un transport vers la droite de 9m: étant périodique, elle est sorti de l'espace et y est revenue.


\newpage

- **Schéma 2 décentré en amont:**

Nous sommes dans le cas ou $a > 0$

Schéma numérique:

$$
\begin{cases}
u_{j}^{n+1} = u_{j}^{n} - \frac{a\Delta t}{\Delta x}(u_{j}^{n}-u_{j-1}^{n}) &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0 
\end{cases}
$$


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0

L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/dx*(un[j]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt

u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[0, 0].plot(x, u_exact, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-1.5, 1.5)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()
while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/dx*(un[j]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt

u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[0, 1].plot(x, u_exact, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-1.5, 1.5)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
u = u0.copy()

while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/dx*(un[j]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt

u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[1, 0].plot(x, u_exact, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-1.5, 1.5)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/dx*(un[j]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt

u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[1, 1].plot(x, u_exact, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-1.5, 1.5)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema decentre en amont", y=1.02)
plt.show()
```

On remarque que pour le schéma décentré en amont, la solution numérique est stable pour $N=100$ et $N=200$. On observe juste une faible diffusion numérique.

\newpage

- **Schéma 2 décentré en aval:**

Schéma numérique:

$$
\begin{cases}
u_{j}^{n+1} = u_{j}^{n} - \frac{a\Delta t}{\Delta x}(u_{j+1}^{n}-u_{j}^{n}) &\ \forall x \in ]0, L[; \forall t>0 \\ 
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0 
\end{cases}
$$





```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0
      
L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)

t = 0
t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - a*dt/dx*(un[j+1]-un[j])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[0, 0].plot(x, u_exact, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-1.5, 1.5)
_=axs[0, 0].grid(True)
  
# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - a*dt/dx*(un[j+1]-un[j])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[0, 1].plot(x, u_exact, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-1.5, 1.5)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)

t = 0
u = u0.copy()

while t <= t1:
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - a*dt/dx*(un[j+1]-un[j])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[1, 0].plot(x, u_exact, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-1.5, 1.5)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - a*dt/dx*(un[j+1]-un[j])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[1, 1].plot(x, u_exact, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-1.5, 1.5)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema decentre en aval", y=1.02)
plt.show()
```


On remarque que pour le schéma décentré en aval, la solution numérique est instable pour $N=100$ et $N=200$. Cela est normal car la condition de stabilité ($a<0$) n'est pas remplie.


\newpage 


- **Schéma 3 (Lax-Friedrichs):**

Schéma numérique:

$$
\begin{cases}
u_{j}^{n+1} = \frac{1}{2}(u_{j-1}^{n}+u_{j+1}^{n}) - \frac{a\Delta t}{2\Delta x}(u_{j+1}^{n}-u_{j-1}^{n}) &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0
      
      
L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j-1]+un[j+1]) - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[0, 0].plot(x, u_exact, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-1.5, 1.5)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j-1]+un[j+1]) - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[0, 1].plot(x, u_exact, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-1.5, 1.5)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
u = u0.copy()

while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j-1]+un[j+1]) - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[1, 0].plot(x, u_exact, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-1.5, 1.5)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j-1]+un[j+1]) - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[1, 1].plot(x, u_exact, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-1.5, 1.5)
_=axs[1, 1].grid(True)
  
_=plt.tight_layout()
_=plt.suptitle("Schema Lax-Friedrichs", y=1.02)
plt.show()
```

On remarque que pour le schéma Lax-Friedrichs, la solution numérique est stable pour $N=100$ et $N=200$. On observe juste une faible diffusion numérique.

\newpage

- **Schéma 4 (Lax-Wendroff):**

Schéma numérique:

$$
\begin{cases}
u_{j}^{n+1} = u_{j}^{n} - \frac{a\Delta t}{\Delta x}(u_{j+1}^{n}-u_{j-1}^{n}) + \frac{a^{2}\Delta t}{2(\Delta x)^{2}}(u_{j-1}^{n}-2u_{j}^{n}+u_{j+1}^{n}) &\ \forall x \in ]0, L[; \forall t>0 \\
u(x, 0) = u_0(x) &\ \forall x \in [0, L]\\
u(0, t) = u(L, t) \ \text{et} \ \frac{\partial u}{\partial x}(L, t)=0 &\ \forall t > 0
\end{cases}
$$


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0
      
L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((a*dt)/(2*dx))*(un[j+1]-un[j-1]) + (((a**2)*dt**2)/(2*dx**2))*(un[j-1]-2*un[j]+un[j+1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[0, 0].plot(x, u_exact, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-1.5, 1.5)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((a*dt)/(2*dx))*(un[j+1]-un[j-1]) + (((a**2)*dt**2)/(2*dx**2))*(un[j-1]-2*un[j]+un[j+1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[0, 1].plot(x, u_exact, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-1.5, 1.5)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
u = u0.copy()

while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((a*dt)/(2*dx))*(un[j+1]-un[j-1]) + (((a**2)*dt**2)/(2*dx**2))*(un[j-1]-2*un[j]+un[j+1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t1)%L) for x in x]

_=axs[1, 0].plot(x, u_exact, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-1.5, 1.5)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((a*dt)/(2*dx))*(un[j+1]-un[j-1]) + (((a**2)*dt**2)/(2*dx**2))*(un[j-1]-2*un[j]+un[j+1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t += dt
    
u_exact = [u_0((x - a*t2)%L) for x in x]

_=axs[1, 1].plot(x, u_exact, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-1.5, 1.5)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema Lax-Wendroff", y=1.02)
plt.show()
```



On remarque que pour le schéma Lax-Wendroff, la solution numérique est stable pour $N=100$ et $N=200$, malgré une diffusion numérique, provenant du terme ajoute par Lax-Wendroff au schéma centre.



\newpage

4) Evaluer erreur en norme $L^1$ de la solution numérique obtenue par chaque schéma au temps $t_1 = 2.5 s$ et pour N = 100. Interpréter.


```{python, message=FALSE, warning=FALSE, echo=FALSE}
# Schéma 1 (centré)
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if 3 <= x <= 4:
        return 1
    else:
        return 0

L = 10
a = 2
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)
u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()
un = np.zeros(N)

t = 0
t1 = 2.5
t2 = 4.5

# Plot for t = t1
while t <= t1:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]
    
    t += dt

u_exact = [u_0((x - a*t1)%L) for x in x]

L1_centre = np.linalg.norm(u-u_exact, 1)
```



```{python, message=FALSE, warning=FALSE, echo=FALSE}
# Schéma 2 décentré en amont
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)

t = 0

while t < 2.5:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - a*dt/dx*(un[j]-un[j-1]) 
    u[0] = u[-1]
    u[-1] = u[-2]

    t = round(t+dt, 2)
    
L1_decentre_amont = np.linalg.norm(u-u_exact, 1)
```



```{python, message=FALSE, warning=FALSE, echo=FALSE}
# Schéma 2 décentré en aval
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)

t = 0

while t < 2.5:
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - a*dt/dx*(un[j+1]-un[j])
    u[0] = u[-1]
    u[-1] = u[-2]

    t = round(t+dt, 2)
    
L1_decentre_aval = np.linalg.norm(u-u_exact, 1)
```



```{python, message=FALSE, warning=FALSE, echo=FALSE}
# Schéma 3 (Lax-Friedrichs)
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)


t = 0

while t < 2.5:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j-1]+un[j+1]) - a*dt/(2*dx)*(un[j+1]-un[j-1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t = round(t+dt, 2)
    
L1_Lax_Friedrichs = np.linalg.norm(u-u_exact, 1)
```


```{python, message=FALSE, warning=FALSE, echo=FALSE}

# Schéma 4 (Lax-Wendroff)
N = 100
CFL = 0.8
dx = L/(N-1)
dt = round(CFL*dx/a, 2)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

u0[int(3/dx):int(4/dx)] = 1

u = u0.copy()

un = np.zeros(N)

t = 0

while t < 2.5:
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((a*dt)/(2*dx))*(un[j+1]-un[j-1]) + (((a**2)*dt**2)/(2*dx**2))*(un[j-1]-2*un[j]+un[j+1])
    u[0] = u[-1]
    u[-1] = u[-2]

    t = round(t+dt, 2)
    
L1_Lax_Wendroff = np.linalg.norm(u-u_exact, 1)
```




```{python, message=FALSE, warning=FALSE, echo=FALSE, out.width='100%'}
# All errors in pandas series
import pandas as pd

errors = pd.Series([L1_centre, L1_decentre_amont, L1_Lax_Friedrichs, L1_Lax_Wendroff], index=['Centre', 'Decentre Amont', 'Lax-Friedrichs', 'Lax-Wendroff'])

_=plt.figure(figsize=(10, 8))
# Plot errors with barplot having error value above bar
ax = errors.plot(kind='bar', figsize=(10, 8), color='skyblue', zorder=2, width=0.5)

for i in ax.patches:
    _=ax.text(i.get_x() + i.get_width() / 2, i.get_height() + 0.1, round(i.get_height(), 2), ha='center', va='bottom')

_=ax.set_xticklabels(ax.get_xticklabels(), rotation=45)  # Rotate xticks by 45 degrees

_=ax.set_xlabel('Schemas numeriques')
_=ax.set_ylabel('Erreur en norme L1')
_=ax.set_title('Erreur en norme L1 pour chaque schema numerique')
_=ax.grid(axis='y', linestyle='--', zorder=1)
plt.show()
```

On remarque que le schéma numérique centre est celui qui a la plus grande erreur en norme $L^1$, suivi du schéma numérique de Lax-Friedrichs. Les schémas numériques décentré en amont et Lax-Wendroff ont des erreurs en norme $L^1$ les plus faibles.

**Données** :

$L = 10 m ,\  a = 2 m/s , \ u_0(x) = 1\  pour\  3 m \leq x \leq 4 m\  et\  0 \ ailleurs.$

Nombre de Courant : $CFL = 0.8$.


\newpage


# 2. Equation de Burgers

On considère maintenant l’équation de Burger suivante:

$$
(E_{2})\left\{
\begin{array}{ll}
\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, t=0) = u_0(x), & \forall x \in [0,L] \\
\frac{\partial u}{\partial x}(0, t)= \frac{\partial u}{\partial x}(L, t)=0 & \forall t > 0
\end{array}
\right. 
$$


5) Reprendre les questions 1), 3) et 4).

1) A l’aide de la méthode des caractéristiques, déterminer la solution exacte $u(x, t)$ du problème $(E_2)$.

Nous allons chercher une courbe caractéristique $\Gamma ((t(s), x(s))$, s étant le paramètre qui décrit la courbe, le long de laquelle l'EDP devient un système d'EDO.


$$
\begin{aligned}
du &= \frac{\partial u}{\partial t}dt + \frac{\partial u}{\partial x}dx\\
\frac{du}{ds} &= \frac{\partial u}{\partial t}\frac{dt}{ds} + \frac{\partial u}{\partial x}\frac{dx}{ds}\\
\frac{du}{ds} &= -u\frac{\partial u}{\partial x}\frac{dt}{ds} + \frac{\partial u}{\partial x}\frac{dx}{ds}\\
\frac{du}{ds} &= \frac{\partial u}{\partial x}\left(\frac{dx}{ds} - u\frac{dt}{ds}\right)\\
\end{aligned}
$$

On voit donc que si on impose $\frac{dx}{ds} - u\frac{dt}{ds} = 0$, alors $\frac{du}{ds} = 0$ et donc u est constant le long de la courbe caractéristique.

On a donc le système d'EDO suivant a résoudre:

$$
\left\{
\begin{array}{ll}
\frac{dx}{dt} = u \ \text{qui donne la courbe caractéristique }\Gamma\\
du = 0 \ \text{qui donne la solution u(x, t) sur cette courbe caractéristique} 
\end{array}
\right.
$$

- **Courbe caractéristique:**

$$
\frac{dx}{dt} = u \ \text{donne} \ x(t) = ut + \xi (avec \ \xi \ \text{une constante reelle d'integration})
$$

```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt

# Define the range of t
t = np.linspace(0, 4, 40)

# Define the values of a
a_values = np.linspace(0, 4, 40)

# Create a figure
_=plt.figure(figsize=(8, 6))

# Plot the characteristic curves for each a
for a in a_values:
    u0 = 0.4 if a < 2 else 0.1
    x = t * u0 + a
    _=plt.plot(x, t, label=f'a={a:.2f}')

# Add labels and title
_=plt.xlabel('x')
_=plt.ylabel('t')
_=plt.title("Characteristic curves for Burger's equation")

# Show the plot
plt.show()
```



- **Solution:**

Sur chaque courbe caractéristique $\Gamma: x-ut=\xi$, on a:

$$
du = 0 \Rightarrow u(x, t) =  cte = f(\xi) \leftarrow i.e. \text{ u ne depend que de } \xi 
$$

Soit alors 

$$
u(x, t) = f(x-ut)
$$
Cette solution doit être retrouvée aussi pour $t=0$.

Or a $t=0$, on a:

$$
u(x, 0) = u_0(x) = f(x) \Rightarrow f(x) = u_0(x)
$$

c'est a dire $$f\equiv u_0$$

On obtient finalement la solution exacte du problème $(E_{1})$:

$$
u(x, t) = u_0(x-ut), \ \forall x \in [0, L], \ \forall t > 0
$$

3) Pour chaque schéma numérique, tracer la solution approchée obtenue au temps $t_1 = 2.5 s$ et $t_2 = 4.5 s$ avec $N = 100$ et $N = 200$. Commenter les résultats obtenus.

- **Schéma 1 (centré)**:

<!-- Transformons l’équation de Burgers en une équation de transport pour pouvoir appliquer le schéma numérique centre. -->

<!-- $$ -->
<!-- \begin{aligned} -->
<!-- \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} &= 0\\ -->
<!-- \frac{\partial u}{\partial t} + \frac{\partial \frac{u^2}{2}}{\partial x} &= 0\\ -->
<!-- \frac{\partial u}{\partial t} + \frac{\partial F(u)}{\partial x} &= 0, \text{ avec } F(u)=\frac{u^2}{2}\\ -->
<!-- \end{aligned} -->
<!-- $$ -->

on a alors le schéma numérique centre:

$$
\begin{cases}
\frac{u_j^{n+1}-u_j^{n}}{\Delta t} + u_{j}^{n}\frac{u_{j+1}^{n}-u_{j-1}^{n}}{2\Delta x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, 0) = u_0(x), & \forall x \in [0,L] \\
u(0, t)=u(L, t) & \forall t > 0
\end{cases}
$$




```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def F(u):
    return (u**2)/2
  
  
def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1


L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

      
x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0
  
t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((dt)/(2*dx))*un[j]*(un[j+1]-un[j-1])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[0, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-.5, 1)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((dt)/(2*dx))*un[j]*(un[j+1]-un[j-1])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[0, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-.5, 1)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

while t <= t1:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((dt)/(2*dx))*un[j]*(un[j+1]-un[j-1])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[1, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-.5, 1)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((dt)/(2*dx))*un[j]*(un[j+1]-un[j-1])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[1, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-.5, 1)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema Centre", y=1.02)
plt.show()
```


On remarque que pour le schéma centre associe a l’équation de Burger, la solution numérique est instable pour $N=100$ et $N=200$. 

\newpage

- **Schéma 2 décentré en amont**:

Transformons l’équation de Burgers en une équation de transport pour pouvoir appliquer le schéma numérique décentré en amont.


$$
\begin{aligned}
\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} &= 0\\
\frac{\partial u}{\partial t} + \frac{\partial \frac{u^2}{2}}{\partial x} &= 0\\
\frac{\partial u}{\partial t} + \frac{\partial F(u)}{\partial x} &= 0, \text{ avec } F(u)=\frac{u^2}{2}\\
\end{aligned}
$$
On a alors le schéma numérique décentré en amont:

$$
\begin{cases}
\frac{u_j^{n+1}-u_j^{n}}{\Delta t} +\frac{F(u_{j}^{n})-F(u_{j-1}^{n})}{\Delta x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, 0) = u_0(x), & \forall x \in [0,L] \\
u(0, t)=u(L, t) & \forall t > 0
\end{cases}
$$

```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def F(u):
    return (u**2)/2

def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1

  
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)


x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N):
        u[j] = un[j] - (dt/dx)*(F(un[j])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[0, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-.5, 1)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N):
        u[j] = un[j] - (dt/dx)*(F(un[j])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[0, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-.5, 1)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

while t <= t1:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N):
        u[j] = un[j] - (dt/dx)*(F(un[j])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[1, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-.5, 1)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N):
        u[j] = un[j] - (dt/dx)*(F(un[j])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[1, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-.5, 1)
_=axs[1, 1].grid(True)
  
_=plt.tight_layout()
_=plt.suptitle("Schema Decentre en Amont", y=1.02)
plt.show()
```

On remarque que pour le schéma décentré en amont associe a l’équation de Burger, la solution numérique est stable pour $N=100$ et $N=200$.


\newpage

- **Schéma 2 décentré en aval**:

On a le schéma numérique décentré en aval:

$$
\begin{cases}
\frac{u_j^{n+1}-u_j^{n}}{\Delta t} +u_{j}^{n}\frac{u_{j+1}^{n}-u_{j}^{n}}{\Delta x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, 0) = u_0(x), & \forall x \in [0,L] \\
u(0, t)=u(L, t) & \forall t > 0
\end{cases}
$$


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1
      
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - (dt/dx)*un[j]*(un[j+1]-un[j])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[0, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-.5, 1)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - (dt/dx)*un[j]*(un[j+1]-un[j])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[0, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-.5, 1)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

while t <= t1:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - (dt/dx)*un[j]*(un[j+1]-un[j])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[1, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-.5, 1)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - (dt/dx)*un[j]*(un[j+1]-un[j])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[1, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-.5, 1)
_=axs[1, 1].grid(True)
  
_=plt.tight_layout()
_=plt.suptitle("Schema Decentre en Aval", y=1.02)
plt.show()
```


On remarque que pour le schéma décentré en aval associe a l’équation de Burger, la solution numérique est instable pour $N=100$ et $N=200$.


\newpage

- **Schéma 3 Lax-Friedrichs**:

On a le schéma numérique Lax-Friedrichs:

$$
\begin{cases}
\frac{u_j^{n+1}-\frac{1}{2}(u_{j+1}^{n}+u_{j-1}^{n})}{\Delta t} +\frac{F(u_{j+1}^{n})-F(u_{j-1}^{n})}{2\Delta x} = 0, & \forall x \in ]0,L[\  ; \ \forall t>0 \\
u(x, 0) = u_0(x), & \forall x \in [0,L] \\
u(0, t)=u(L, t) & \forall t > 0
\end{cases}
$$


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def F(u):
    return (u**2)/2
  
def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1
      
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j+1]+un[j-1]) - (dt/(2*dx))*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[0, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-.5, 1)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j+1]+un[j-1]) - (dt/(2*dx))*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[0, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-.5, 1)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

while t <= t1:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j+1]+un[j-1]) - (dt/(2*dx))*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[1, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-.5, 1)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j+1]+un[j-1]) - (dt/(2*dx))*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[1, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-.5, 1)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema Lax-Friedrichs", y=1.02)
plt.show()
```


On remarque que pour le schéma Lax-Friedrichs associe a l’équation de Burger, la solution numérique est stable pour $N=100$ et $N=200$.

\newpage

- **Schéma 4 Lax-Wendroff**:

On a le schéma numérique Lax-Wendroff:

$$
\begin{cases}
u_j^{n+1}=u_{j}^{n}+\frac{\lambda^2}{2}u_{j}^{n}(F(u_{j-1}^{n})-2F(u_{j}^{n})+F(u_{j+1}^{n}))-\alpha\frac{\lambda}{2}(F(u_{j+1}^{n})-F(u_{j-1}^{n})), & \forall x \in ]0,L[\  ; \ \forall t>0  \\
u(x, 0) = u_0(x), & \forall x \in [0,L] \\
u(0, t)=u(L, t) & \forall t > 0
\end{cases}
$$,


avec $\alpha=1-\frac{\Delta t}{2\Delta x}(u_{j+1}^{n}-u_{j}^{n}), \text{ et } \lambda=\frac{\Delta t}{\Delta x}$.


```{python, message=FALSE, warning=FALSE, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def F(u):
    return (u**2)/2
  
def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1
      
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5

fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        alpha = 1 - (dt/(2*dx))*(un[j+1]-un[j])
        lambda_ = (dt/dx)
        u[j] = un[j] + (1/alpha)*(lambda_**2/2)*(F(un[j-1])-2*F(un[j])+F(un[j+1])) - (lambda_/2)*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[0, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 0].plot(x, u, label='Approximate Solution')
_=axs[0, 0].set_xlabel('x')
_=axs[0, 0].set_ylabel('u')
_=axs[0, 0].set_title(f't = {t1} et N = {N}')
_=axs[0, 0].legend()
_=axs[0, 0].set_ylim(-.5, 1)
_=axs[0, 0].grid(True)

# Plot for t = t2
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        alpha = 1 - (dt/(2*dx))*(un[j+1]-un[j])
        lambda_ = (dt/dx)
        u[j] = un[j] + un[j]*(lambda_**2/2)*(F(un[j-1])-2*F(un[j])+F(un[j+1])) - alpha*(lambda_/2)*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[0, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[0, 1].plot(x, u, label='Approximate Solution')
_=axs[0, 1].set_xlabel('x')
_=axs[0, 1].set_ylabel('u')
_=axs[0, 1].set_title(f't = {t2} et N = {N}')
_=axs[0, 1].legend()
_=axs[0, 1].set_ylim(-.5, 1)
_=axs[0, 1].grid(True)

# Plot for t = t1 with N=200
N = 200
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

while t <= t1:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        alpha = 1 - (dt/(2*dx))*(un[j+1]-un[j])
        lambda_ = (dt/dx)
        u[j] = un[j] + un[j]*(lambda_**2/2)*(F(un[j-1])-2*F(un[j])+F(un[j+1])) - alpha*(lambda_/2)*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

_=axs[1, 0].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 0].plot(x, u, label='Approximate Solution')
_=axs[1, 0].set_xlabel('x')
_=axs[1, 0].set_ylabel('u')
_=axs[1, 0].set_title(f't = {t1} et N = {N}')
_=axs[1, 0].legend()
_=axs[1, 0].set_ylim(-.5, 1)
_=axs[1, 0].grid(True)

# Plot for t = t2 with N=200
t = 0
u = u0.copy()

while t <= t2:
    dt = (CFL*dx)/(max(abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        alpha = 1 - (dt/(2*dx))*(un[j+1]-un[j])
        lambda_ = (dt/dx)
        u[j] = un[j] + un[j]*(lambda_**2/2)*(F(un[j-1])-2*F(un[j])+F(un[j+1])) - alpha*(lambda_/2)*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t2) for y in x]

_=axs[1, 1].plot(x, u_exacte, label='Exact Solution')
_=axs[1, 1].plot(x, u, label='Approximate Solution')
_=axs[1, 1].set_xlabel('x')
_=axs[1, 1].set_ylabel('u')
_=axs[1, 1].set_title(f't = {t2} et N = {N}')
_=axs[1, 1].legend()
_=axs[1, 1].set_ylim(-.5, 1)
_=axs[1, 1].grid(True)

_=plt.tight_layout()
_=plt.suptitle("Schema Lax-Wendroff", y=1.02)
plt.show()
```


On remarque que pour le schéma Lax-Wendroff associe a l’équation de Burger, la solution numérique est stable pour $N=100$ et $N=200$.

\newpage

4) Evaluer Schéma en norme $L^1$ de la solution numérique obtenue par chaque schéma au temps $t_1 = 2.5 s$ et pour N = 100. Interpréter.


```{python, message=FALSE, warning=FALSE, echo=FALSE}
# Schéma 1 (centré)
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")


def u_0(x):
    if  x < 2:
        return 0.4
    else:
        return 0.1
      
def F(u):
    return (u**2)/2
  
  
def u_exact(x, t):
    if ((x-2)/t) < 0.25:
        return 0.4
    else:
        return 0.1


L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

      
x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0
  
t1 = 2.5
t2 = 4.5


# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = un[j] - ((dt)/(2*dx))*un[j]*(un[j+1]-un[j-1])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

L1_centre = np.linalg.norm(u-u_exacte, 1)


# Schéma 2 (décentré en amont)
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)


x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5


# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N):
        u[j] = un[j] - (dt/dx)*(F(un[j])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

L1_amont = np.linalg.norm(u-u_exacte, 1)


# Schéma 3 (décentré en aval)
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5


# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(0, N-1):
        u[j] = un[j] - (dt/dx)*un[j]*(un[j+1]-un[j])
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

L1_aval = np.linalg.norm(u-u_exacte, 1)

# Schéma 4 (Lax-Friedrichs)

L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5


# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        u[j] = 0.5*(un[j+1]+un[j-1]) - (dt/(2*dx))*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

L1_friedrichs = np.linalg.norm(u-u_exacte, 1)

# Schéma 5 (Lax-Wendroff)
L = 6
N = 100
CFL = 0.8
dx = L/(N-1)

x = np.linspace(0, L, N)

u0 = np.zeros(N)

for i in range(N):
    u0[i] = u_0(x[i])
    
u = u0.copy()
un = np.zeros(N)

t = 0

t1 = 2.5
t2 = 4.5


# Plot for t = t1
while t <= t1:
    dt = (CFL*dx)/(max(np.abs(u)))
    un = u.copy()
    for j in range(1, N-1):
        alpha = 1 - (dt/(2*dx))*(un[j+1]-un[j])
        lambda_ = (dt/dx)
        u[j] = un[j] + un[j]*(lambda_**2/2)*(F(un[j-1])-2*F(un[j])+F(un[j+1])) - alpha*(lambda_/2)*(F(un[j+1])-F(un[j-1]))
    u[0] = u[1]
    u[-1] = u[-2]
    
    t += dt
    
u_exacte = [u_exact(y, t1) for y in x]

L1_wendroff = np.linalg.norm(u-u_exacte, 1)

# All errors in pandas series
import pandas as pd

errors = pd.Series([L1_centre, L1_amont, L1_friedrichs, L1_wendroff], index=['Centre', 'Decentre Amont', 'Lax-Friedrichs', 'Lax-Wendroff'])

_=plt.figure(figsize=(10, 8))
# Plot errors with barplot having error value above bar
ax = errors.plot(kind='bar', figsize=(10, 8), color='skyblue', zorder=2, width=0.5)

for i in ax.patches:
    _=ax.text(i.get_x() + i.get_width() / 2, i.get_height() + 0.1, round(i.get_height(), 2), ha='center', va='bottom')

_=ax.set_xticklabels(ax.get_xticklabels(), rotation=45)  # Rotate xticks by 45 degrees

_=ax.set_xlabel('Schemas numeriques')
_=ax.set_ylabel('Erreur en norme L1')
_=ax.set_title('Erreur en norme L1 pour chaque schema numerique')
_=ax.grid(axis='y', linestyle='--', zorder=1)
plt.show()
```

On remarque que le schéma numérique décentré en amont a la plus petite erreur en norme $L^1$ au temps $t_1 = 2.5 s$ et pour $N = 100$. En effet, le schéma numérique décentré en amont apparaît être le schéma numérique le plus précis pour résoudre l’équation de Burger au sein de notre expérience.

**Données** :

$L = 6m ,\  u_0(x) = 0.4\  pour\  x < 2m \ et \ 0.1\ ailleurs.\ CFL = 0.8$.



# References

```{bibliography}
1. https://folk.ntnu.no/leifh/teaching/tkt4140/._main075.html
2. https://uma.ensta-paristech.fr/conf/tipe/2014/talks/scilab2/transport_burgers%202p.pdf
```



